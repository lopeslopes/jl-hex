import numpy as np
import spglib
import matplotlib.pyplot as plt


def read_lattice(path):
    try:
        with open(file=path) as f:
            data = f.readlines()
        points = []
        for line in data:
            aux = line.split(";")
            points.append([float(aux[0]), float(aux[1]), 0.0])

        # points = np.array(points)
        return points
    except:
        print("No file found in "+path)
        return 0


a = 2.46
d = np.sqrt((a**2) / (2 * (1 - np.cos(2 * np.pi / 3))))
d1 = [d * np.cos(np.pi / 6), d * np.sin(np.pi / 6), 0.0]

# DEFINE LATTICE VECTORS
# lattice = np.array([[4428.000519758899, 2484.072918780167, 0.0],
#                     [62.730007363230285, 5076.797397472701, 0.0],
#                     [0.0, 0.0, 100000000.0]])

lattice = np.array([[4428.000519758899, 2484.072918780167, 0.0],
                    [-4365.2705123956675, 2592.7244786925335, 0.0],
                    [0.0, 0.0, 100000000.0]])


# lattice = np.array([[1.0, 0.0, 0.0],
#                     [0.0, 1.0, 0.0],
#                     [0.0, 0.0, 1.0]])

# TESTING LENGTHS
dist1 = np.sqrt(lattice[0,0]**2 + lattice[0,1]**2 + lattice[0,2]**2)
dist2 = np.sqrt(lattice[1,0]**2 + lattice[1,1]**2 + lattice[1,2]**2)
dist3 = np.sqrt(lattice[2,0]**2 + lattice[2,1]**2 + lattice[2,2]**2)
print(f"{dist1=}")
print(f"{dist2=}")
print(f"{dist3=}")

# TESTING OTHER ATOM POSITIONS TO DEBUG SPGLIB
positions = np.array([[0.0, 0.0, 0.0]])
numbers = [1]
graphene_structure = (lattice, positions, numbers)

# SYMMETRY CALCULATIONS
sym_data = spglib.get_symmetry_dataset(graphene_structure, symprec=1e-5)
print(f"{sym_data.number=}")
print(f"{sym_data.hall_number=}")
print(f"{sym_data.international=}")
print(f"{sym_data.hall=}")

# GAMMA CENTERED MESH
mesh = [75, 75, 1]
mapping, grid = spglib.get_ir_reciprocal_mesh(mesh, graphene_structure, is_shift=[0, 0, 0])
# for i, (ir_gp_id, gp) in enumerate(zip(mapping, grid)):
#    print("%3d ->%3d %s" % (i, ir_gp_id, gp.astype(float) / mesh))

# IRREDUCIBLE K-POINTS
print("Number of ir-kpoints: %d" % len(np.unique(mapping)))
unique_kpts = grid[np.unique(mapping)] / np.array(mesh, dtype=float)

# ANALYZING ROTATIONS AND TRANSLATIONS
full_bz = []
for uk in unique_kpts:
    for r in sym_data.rotations:
        # new_point = r @ uk
        new_point = np.transpose(r) @ uk
        full_bz.append(new_point)

full_bz = np.array(np.transpose(full_bz))
unique_kpts = np.transpose(unique_kpts)

# PLOT OF K POINTS
# ax1 = plt.subplot(211, projection="3d")
# ax1.scatter(unique_kpts[0, :], unique_kpts[1, :], unique_kpts[2, :], color="magenta")
# ax1.scatter(full_bz[0, :], full_bz[1, :], full_bz[2, :], color="gray", alpha=0.1)

ax1 = plt.subplot(211)
ax1.scatter(unique_kpts[0, :], unique_kpts[1, :], color="magenta")
ax1.scatter(full_bz[0, :], full_bz[1, :], color="gray", alpha=0.075)

# READING LATTICES GENERATED BY JULIA PROGRAM
atomsAA = read_lattice("data/0.0191435_0.001/latticeAA.dat")
lenAA = len(atomsAA)

atomsAB = read_lattice("data/0.0191435_0.001/latticeAB.dat")
lenAB = len(atomsAB)

atomsBA = read_lattice("data/0.0191435_0.001/latticeBA.dat")
lenBA = len(atomsBA)

atomsBB = read_lattice("data/0.0191435_0.001/latticeBB.dat")
lenBB = len(atomsBB)

atomsAA = np.array(atomsAA)
atomsBA = np.array(atomsBA)
atomsAB = np.array(atomsAB)
atomsBB = np.array(atomsBB)

# PLOT OF DIRECT SPACE THINGS
ax2 = plt.subplot(212)

if (lenAA > 1):
    ax2.scatter(atomsAA[:,0], atomsAA[:,1], s=20, color="c")
if (lenBA > 1):
    ax2.scatter(atomsBA[:,0], atomsBA[:,1], s=20, color="green")
if (lenAB > 1):
    ax2.scatter(atomsAB[:,0], atomsAB[:,1], s=20, color="orange")
if (lenBB > 1):
    ax2.scatter(atomsBB[:,0], atomsBB[:,1], s=20, color="red")

ax2.quiver(0.0, 0.0, lattice[0,0], lattice[0,1], angles="xy", scale_units="xy", scale=1)
ax2.quiver(0.0, 0.0, lattice[1,0], lattice[1,1], angles="xy", scale_units="xy", scale=1)
# ax2.quiver(0.0, 0.0, lattice[2,0], lattice[2,1])

ax1.set_aspect("equal")
ax2.set_aspect("equal")
ax2.set_xlim([-10000.0, 10000.0])
ax2.set_ylim([-10000.0, 10000.0])

plt.show()
