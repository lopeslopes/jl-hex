import numpy as np
import spglib
import matplotlib.pyplot as plt


def read_lattice(path):
    try:
        with open(file=path) as f:
            data = f.readlines()
        points = []
        for line in data:
            aux = line.split(";")
            points.append([float(aux[0]), float(aux[1]), 0.0])

        # points = np.array(points)
        return points
    except:
        print("No file found in "+path)
        return 0


a = 2.46
d = np.sqrt((a**2) / (2 * (1 - np.cos(2 * np.pi / 3))))
d1 = [d * np.cos(np.pi / 6), d * np.sin(np.pi / 6), 0.0]

# DEFINE LATTICE VECTORS

# HEXAGONAL CELL MATCHING OVERLAP LATTICES
# lattice = np.array([[4428.000519758899, 2484.072918780167, 0.0],
#                     [-4365.2705123956675, 2592.7244786925335, 0.0],
#                     [0.0, 0.0, 100000000.0]])

# SIMPLE CUBIC LATTICE FOR TESTING
# lattice = np.array([[1.0, 0.0, 0.0],
#                     [0.0, 1.0, 0.0],
#                     [0.0, 0.0, 1.0]])

# BCC LATTICE FOR TESTING
# lattice = np.array([[-0.5, 0.5, 0.5],
#                     [0.5, -0.5, 0.5],
#                     [0.5, 0.5, -0.5]])

# FCC LATTICE FOR TESTING
lattice = np.array([[0.5, 0.5, 0.0],
                    [0.0, 0.5, 0.5],
                    [0.5, 0.0, 0.5]])

# TESTING LENGTHS
dist1 = np.sqrt(lattice[0,0]**2 + lattice[0,1]**2 + lattice[0,2]**2)
dist2 = np.sqrt(lattice[1,0]**2 + lattice[1,1]**2 + lattice[1,2]**2)
dist3 = np.sqrt(lattice[2,0]**2 + lattice[2,1]**2 + lattice[2,2]**2)
print(f"|a1| = {dist1}")
print(f"|a2| = {dist2}")
print(f"|a3| = {dist3}")

# TESTING OTHER ATOM POSITIONS TO DEBUG SPGLIB
# positions = np.array([[0.0, 0.0, 0.0],
#                       [-1322.249830067740, 2493.3053571691007, 0.0]])
# numbers = [1, 2]
#
# positions = np.array([[0.0, 0.0, 0.0],
#                       [-1322.249830067740, 2493.3053571691007, 0.0],
#                       [1496.9101757073777, 2520.290105417622, 0.0],
#                       [-1.2306879586268324, 128.5354838445569, 0.0]])
# numbers = [1, 2, 3, 4]

positions = np.array([[0.0, 0.0, 0.0]])
numbers = [1]

graphene_structure = (lattice, positions, numbers)

# SYMMETRY CALCULATIONS
sym_data = spglib.get_symmetry_dataset(graphene_structure, symprec=1e-5)
print(f"Group number:           {sym_data.number}")
print(f"Hall number:            {sym_data.hall_number}")
print(f"International notation: {sym_data.international}")
print(f"Hall notation:          {sym_data.hall}")

# GAMMA CENTERED MESH
mesh = [50, 50, 50]
mapping, grid = spglib.get_ir_reciprocal_mesh(mesh, graphene_structure, is_shift=[0, 0, 0])

# IRREDUCIBLE K-POINTS
ind_unique, counts = np.unique(mapping, return_counts=True)
print(f"Number of irreducible k-points: {len(ind_unique)}")
unique_kpts = grid[ind_unique] / np.array(mesh, dtype=float)
kpts = grid / np.array(mesh, dtype=float)
unique_kpts = np.transpose(unique_kpts)

# print(counts)

# ANALYZING ROTATIONS AND TRANSLATIONS
n_eqv = []
categories = []
for i in range(len(ind_unique)):
    cc = max(counts)/counts[i]
    if cc not in n_eqv:
        n_eqv.append(int(cc))
        categories.append([])

    categories[n_eqv.index(cc)].append(kpts[ind_unique[i]])

print(n_eqv)

# full_bz = []
# n_rot = len(sym_data.rotations)
# n_trans = 0  # len(sym_data.translations)
# max_sym = max(counts)
# for i in range(len(ind_unique)):
#     if counts[i] == max_sym/counts[i]:
#         pt = kpts[ind_unique[i]]
#         full_bz.append(pt)
#         for j in range(n_rot):
#             full_bz.append(sym_data.rotations[j] @ pt)
#         # for k in range(n_trans):
#         #     if sym_data.translations[k] != np.array([0.0, 0.0, 0.0]):
#         #         full_bz.append(sym_data.translations[k] + pt)
# # print(n_rot, n_trans)
# # print(sym_data.translations)
# 
# full_bz = np.transpose(full_bz)

# PLOTTING K SPACE STUFF
ax1 = plt.subplot(211, projection="3d")
leg = []
for i in range(len(categories)):
    c = categories[i]
    c_tp = np.transpose(c)
    ax1.scatter(c_tp[0, :], c_tp[1, :], c_tp[2, :], s=50)
    leg.append(f"{n_eqv[i]} sym.")
ax1.legend(leg, loc="center left", bbox_to_anchor=(1, 0.5))


ax2 = plt.subplot(212, projection="3d")
chosen = 3
c = categories[chosen]
c_tp = np.transpose(c)
ax2.scatter(c_tp[0,:], c_tp[1,:], c_tp[2,:])
ax2.legend([n_eqv[chosen]], loc="center left", bbox_to_anchor=(1, 0.5))
xlim1, xlim2, ylim1, ylim2, zlim1, zlim2 = ax1.axis()
# xlim1, xlim2, ylim1, ylim2 = ax1.axis()
ax2.set(xlim=(xlim1,xlim2), ylim=(ylim1,ylim2), zlim=(zlim1,zlim2))

# ax2 = plt.subplot(212, projection="3d")
# ax2.scatter(full_bz[0,:], full_bz[1,:], full_bz[2,:], s=50)

# # PLOT OF K POINTS
# ax1 = plt.subplot(111, projection="3d")
# ax1.scatter(unique_kpts[0, :], unique_kpts[1, :], unique_kpts[2, :], color="magenta")
# ax1.scatter(kpts[0, :], kpts[1, :], kpts[2, :], color="gray", alpha=0.1)

# ax1 = plt.subplot(211)
# ax1.scatter(unique_kpts[0, :], unique_kpts[1, :], color="magenta")

# READING LATTICES GENERATED BY JULIA PROGRAM
# atomsAA = np.array(read_lattice("data/0.0191435_0.001/latticeAA.dat"))
# lenAA = len(atomsAA)
# atomsAB = np.array(read_lattice("data/0.0191435_0.001/latticeAB.dat"))
# lenAB = len(atomsAB)
# atomsBA = np.array(read_lattice("data/0.0191435_0.001/latticeBA.dat"))
# lenBA = len(atomsBA)
# atomsBB = np.array(read_lattice("data/0.0191435_0.001/latticeBB.dat"))
# lenBB = len(atomsBB)
# 
# # PLOT OF DIRECT SPACE THINGS
# ax2 = plt.subplot(212)
# # ax2 = plt.subplot(212, projection="3d")
# 
# if (lenAA > 1):
#     ax2.scatter(atomsAA[:,0], atomsAA[:,1], s=20, color="c")
# if (lenBA > 1):
#     ax2.scatter(atomsBA[:,0], atomsBA[:,1], s=20, color="green")
# if (lenAB > 1):
#     ax2.scatter(atomsAB[:,0], atomsAB[:,1], s=20, color="orange")
# if (lenBB > 1):
#     ax2.scatter(atomsBB[:,0], atomsBB[:,1], s=20, color="red")
# 
# ax2.quiver(0.0, 0.0, lattice[0,0], lattice[0,1], angles="xy", scale_units="xy", scale=1)
# ax2.quiver(0.0, 0.0, lattice[1,0], lattice[1,1], angles="xy", scale_units="xy", scale=1)
# 
# # ax2.quiver(0.0, 0.0, 0.0, lattice[0,0], lattice[0,1], lattice[0,2])
# # ax2.quiver(0.0, 0.0, 0.0, lattice[1,0], lattice[1,1], lattice[1,2])
# # ax2.quiver(0.0, 0.0, 0.0, lattice[2,0], lattice[2,1], lattice[2,2])
# 
# ax1.set_aspect("equal")
# ax2.set_aspect("equal")
# ax2.set_xlim([-10000.0, 10000.0])
# ax2.set_ylim([-10000.0, 10000.0])
# 
# ax2.legend(["AA", "BA", "AB", "BB"])

plt.show()
